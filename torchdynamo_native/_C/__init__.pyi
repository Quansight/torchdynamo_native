from typing import List

import torch

class Value: ...

class Function:
    ...
    def __init__(self, id: str, in_tensors: int, out_tensors: int) -> None: ...

    def set_placeholder(self, i: int, name: str) -> Value: ...

    def set_outputs(self, outputs: List[Value]) -> List[Value]: ...
    def set_output(self, output: Value) -> Value: ...

    def add_call(self, symbolname: str, opname: str, args: List[Value]) -> Value: ...

    def dump(self) -> None: ...
    def finalize(self) -> None: ...

    def build_bool(self, b: bool) -> Value: ...
    def build_scalar_type(self, ty: torch.dtype): ...
    def build_optional_tensorlist(self, tensors: List[torch.Tensor]) -> Value: ...
    def build_scalar_int(self, n: int) -> Value: ...

    def build_integer(self, n: int) -> Value: ...

    def build_arrayref_int(self, ints: List[int]) -> Value: ...
    def build_arrayref_tensor(self, tensors: List[torch.Tensor]) -> Value: ...
    def build_arrayref_lit_int(self, ints: List[int]) -> Value: ...
    def build_arrayref_lit_tensor(self, tensors: List[torch.Tensor]) -> Value: ...

    def build_nullopt_tensor(self) -> Value: ...

    def build_optional_tensor(self, tensor: Value) -> Value: ...
    def build_optional_lit_int(self, int: Value) -> Value: ...
    def build_optional_lit_scalar_type(self, ty: torch.dtype) -> Value: ...

    def into_jit(self) -> "JITFunction": ...

class JITFunction:
    ...
    def run(in_tensors: List[torch.Tensor]) -> List[torch.Tensor]: ...
